#!/usr/bin/env node

/**
 * Script para verifica√ß√£o de formata√ß√£o markdown
 * Valida estrutura, consist√™ncia e diretrizes de estilo
 */

const fs = require('fs');
const path = require('path');

class FormatChecker {
  constructor() {
    this.stats = {
      filesChecked: 0,
      issuesFound: 0,
      warningsFound: 0,
      fixableIssues: 0
    };
    
    this.issues = [];
    this.warnings = [];
    this.rules = this.loadRules();
  }

  loadRules() {
    return {
      // Regras de estrutura
      maxLineLength: 120,
      requireH1: true,
      maxConsecutiveEmptyLines: 2,
      requireFrontMatter: true,
      
      // Regras de formata√ß√£o
      codeBlockLanguage: true,
      linkValidation: true,
      imageAltText: true,
      headingStyle: 'atx', // # Heading vs Heading\n=======
      
      // Regras de estilo
      listStyle: 'dash', // - vs *
      emphasisStyle: 'asterisk', // *emphasis* vs _emphasis_
      strongStyle: 'asterisk', // **strong** vs __strong__
      
      // Regras espec√≠ficas
      trailingWhitespace: true,
      tabsVsSpaces: 'spaces',
      punctuationSpacing: true
    };
  }

  async check() {
    console.log('üìê Iniciando verifica√ß√£o de formata√ß√£o...\n');
    
    try {
      await this.scanFiles();
      await this.generateReport();
    } catch (error) {
      console.error('‚ùå Erro durante verifica√ß√£o:', error.message);
      process.exit(1);
    }
  }

  async scanFiles() {
    console.log('üìÑ Escaneando arquivos...');
    
    const docsDirs = ['docs', 'src/pages'];
    
    for (const dir of docsDirs) {
      if (fs.existsSync(dir)) {
        await this.scanDirectory(dir);
      }
    }
    
    console.log(`üìÑ ${this.stats.filesChecked} arquivos verificados\n`);
  }

  async scanDirectory(dir, basePath = '') {
    const files = fs.readdirSync(dir, { withFileTypes: true });
    
    for (const file of files) {
      const fullPath = path.join(dir, file.name);
      const relativePath = path.join(basePath, file.name);
      
      if (file.isDirectory()) {
        await this.scanDirectory(fullPath, relativePath);
      } else if (this.isMarkdownFile(file.name)) {
        await this.checkFile(fullPath, relativePath);
      }
    }
  }

  isMarkdownFile(filename) {
    return ['.md', '.mdx'].includes(path.extname(filename));
  }

  async checkFile(filePath, relativePath) {
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      const lines = content.split('\n');
      
      this.stats.filesChecked++;
      
      console.log(`   üìê Verificando: ${relativePath}`);
      
      // Verifica√ß√µes gerais do arquivo
      this.checkFileStructure(content, lines, relativePath);
      
      // Verifica√ß√µes linha por linha
      lines.forEach((line, index) => {
        this.checkLine(line, index + 1, relativePath);
      });
      
      // Verifica√ß√µes de conte√∫do
      this.checkContent(content, relativePath);
      
    } catch (error) {
      console.error(`‚ùå Erro ao verificar ${filePath}:`, error.message);
    }
  }

  checkFileStructure(content, lines, filePath) {
    // Verificar front matter
    if (this.rules.requireFrontMatter) {
      if (!content.startsWith('---\n')) {
        this.addIssue('error', filePath, 1, 'Front matter ausente no in√≠cio do arquivo');
      }
    }
    
    // Verificar H1
    if (this.rules.requireH1) {
      const hasH1 = lines.some(line => /^#\s+/.test(line));
      if (!hasH1) {
        this.addIssue('error', filePath, 1, 'Heading H1 ausente');
      }
    }
    
    // Verificar linhas vazias consecutivas
    let emptyLineCount = 0;
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].trim() === '') {
        emptyLineCount++;
        if (emptyLineCount > this.rules.maxConsecutiveEmptyLines) {
          this.addIssue('warning', filePath, i + 1, 
            `Muitas linhas vazias consecutivas (${emptyLineCount})`);
        }
      } else {
        emptyLineCount = 0;
      }
    }
    
    // Verificar final do arquivo
    if (content.endsWith('\n\n\n')) {
      this.addIssue('warning', filePath, lines.length, 
        'Muitas linhas vazias no final do arquivo');
    } else if (!content.endsWith('\n')) {
      this.addIssue('warning', filePath, lines.length, 
        'Arquivo deve terminar com uma linha vazia');
    }
  }

  checkLine(line, lineNumber, filePath) {
    // Verificar comprimento da linha
    if (line.length > this.rules.maxLineLength) {
      this.addIssue('warning', filePath, lineNumber, 
        `Linha muito longa (${line.length} caracteres, m√°ximo ${this.rules.maxLineLength})`);
    }
    
    // Verificar whitespace no final
    if (this.rules.trailingWhitespace && line.endsWith(' ')) {
      this.addIssue('warning', filePath, lineNumber, 
        'Espa√ßos em branco no final da linha', true);
    }
    
    // Verificar tabs vs espa√ßos
    if (this.rules.tabsVsSpaces === 'spaces' && line.includes('\t')) {
      this.addIssue('warning', filePath, lineNumber, 
        'Usar espa√ßos ao inv√©s de tabs', true);
    }
    
    // Verificar headings
    this.checkHeadings(line, lineNumber, filePath);
    
    // Verificar listas
    this.checkLists(line, lineNumber, filePath);
    
    // Verificar √™nfase e negrito
    this.checkEmphasis(line, lineNumber, filePath);
    
    // Verificar pontua√ß√£o
    this.checkPunctuation(line, lineNumber, filePath);
  }

  checkHeadings(line, lineNumber, filePath) {
    // Verificar estilo ATX vs Setext
    if (this.rules.headingStyle === 'atx') {
      if (/^.+\n[=-]+$/.test(line)) {
        this.addIssue('warning', filePath, lineNumber, 
          'Usar estilo ATX para headings (# Heading)', true);
      }
    }
    
    // Verificar heading ATX
    const headingMatch = line.match(/^(#{1,6})\s*(.*)$/);
    if (headingMatch) {
      const level = headingMatch[1].length;
      const text = headingMatch[2];
      
      // Verificar espa√ßo ap√≥s #
      if (!text && line !== headingMatch[1]) {
        this.addIssue('warning', filePath, lineNumber, 
          'Adicionar espa√ßo ap√≥s # em headings', true);
      }
      
      // Verificar heading vazio
      if (!text.trim()) {
        this.addIssue('error', filePath, lineNumber, 'Heading vazio');
      }
      
      // Verificar # no final (GitHub style)
      if (text.endsWith('#')) {
        this.addIssue('warning', filePath, lineNumber, 
          'Remover # no final do heading', true);
      }
    }
  }

  checkLists(line, lineNumber, filePath) {
    // Verificar estilo de listas
    const listMatch = line.match(/^(\s*)([*+-]|\d+\.)\s+(.*)$/);
    if (listMatch) {
      const marker = listMatch[2];
      
      // Verificar estilo de marcador
      if (this.rules.listStyle === 'dash' && (marker === '*' || marker === '+')) {
        this.addIssue('warning', filePath, lineNumber, 
          'Usar - para listas n√£o ordenadas', true);
      } else if (this.rules.listStyle === 'asterisk' && marker === '-') {
        this.addIssue('warning', filePath, lineNumber, 
          'Usar * para listas n√£o ordenadas', true);
      }
      
      // Verificar espa√ßo ap√≥s marcador
      if (!line.match(/^(\s*)([*+-]|\d+\.)\s+/)) {
        this.addIssue('warning', filePath, lineNumber, 
          'Adicionar espa√ßo ap√≥s marcador de lista', true);
      }
    }
  }

  checkEmphasis(line, lineNumber, filePath) {
    // Verificar √™nfase simples
    if (this.rules.emphasisStyle === 'asterisk') {
      if (/_[^_]+_/.test(line) && !line.includes('__')) {
        this.addIssue('warning', filePath, lineNumber, 
          'Usar * para √™nfase ao inv√©s de _', true);
      }
    } else if (this.rules.emphasisStyle === 'underscore') {
      if (/\*[^*]+\*/.test(line) && !line.includes('**')) {
        this.addIssue('warning', filePath, lineNumber, 
          'Usar _ para √™nfase ao inv√©s de *', true);
      }
    }
    
    // Verificar negrito
    if (this.rules.strongStyle === 'asterisk') {
      if (/__[^_]+__/.test(line)) {
        this.addIssue('warning', filePath, lineNumber, 
          'Usar ** para negrito ao inv√©s de __', true);
      }
    } else if (this.rules.strongStyle === 'underscore') {
      if (/\*\*[^*]+\*\*/.test(line)) {
        this.addIssue('warning', filePath, lineNumber, 
          'Usar __ para negrito ao inv√©s de **', true);
      }
    }
  }

  checkPunctuation(line, lineNumber, filePath) {
    if (!this.rules.punctuationSpacing) return;
    
    // Verificar espa√ßos em pontua√ß√£o
    const punctuationIssues = [
      { pattern: /\s+[.,;:!?]/, message: 'Remover espa√ßo antes da pontua√ß√£o' },
      { pattern: /[.,;:!?][^\s]/, message: 'Adicionar espa√ßo ap√≥s pontua√ß√£o' },
      { pattern: /\s{2,}/, message: 'M√∫ltiplos espa√ßos consecutivos' }
    ];
    
    punctuationIssues.forEach(issue => {
      if (issue.pattern.test(line)) {
        this.addIssue('warning', filePath, lineNumber, issue.message, true);
      }
    });
  }

  checkContent(content, filePath) {
    // Verificar blocos de c√≥digo
    if (this.rules.codeBlockLanguage) {
      const codeBlocks = content.match(/```[\s\S]*?```/g) || [];
      codeBlocks.forEach(block => {
        if (block.startsWith('```\n')) {
          const lineNumber = content.substring(0, content.indexOf(block))
            .split('\n').length;
          this.addIssue('warning', filePath, lineNumber, 
            'Especificar linguagem em blocos de c√≥digo', true);
        }
      });
    }
    
    // Verificar links
    if (this.rules.linkValidation) {
      this.checkLinks(content, filePath);
    }
    
    // Verificar imagens
    if (this.rules.imageAltText) {
      this.checkImages(content, filePath);
    }
  }

  checkLinks(content, filePath) {
    const linkRegex = /\[([^\]]*)\]\(([^)]+)\)/g;
    let match;
    
    while ((match = linkRegex.exec(content)) !== null) {
      const linkText = match[1];
      const linkUrl = match[2];
      const lineNumber = content.substring(0, match.index).split('\n').length;
      
      // Verificar texto do link
      if (!linkText.trim()) {
        this.addIssue('warning', filePath, lineNumber, 
          'Link sem texto descritivo');
      }
      
      // Verificar URLs internas
      if (!linkUrl.startsWith('http') && !linkUrl.startsWith('#')) {
        const linkPath = linkUrl.replace(/^\//, '').replace(/#.*$/, '');
        if (linkPath && !fs.existsSync(linkPath)) {
          this.addIssue('error', filePath, lineNumber, 
            `Link interno quebrado: ${linkUrl}`);
        }
      }
      
      // Verificar URLs repetidas
      if (linkText.toLowerCase() === 'aqui' || linkText.toLowerCase() === 'clique aqui') {
        this.addIssue('warning', filePath, lineNumber, 
          'Evitar texto de link gen√©rico como "aqui" ou "clique aqui"');
      }
    }
  }

  checkImages(content, filePath) {
    const imgRegex = /!\[([^\]]*)\]\(([^)]+)\)/g;
    let match;
    
    while ((match = imgRegex.exec(content)) !== null) {
      const altText = match[1];
      const imgSrc = match[2];
      const lineNumber = content.substring(0, match.index).split('\n').length;
      
      // Verificar alt text
      if (!altText.trim()) {
        this.addIssue('error', filePath, lineNumber, 
          `Imagem sem alt text: ${imgSrc}`);
      }
      
      // Verificar se a imagem existe
      if (!imgSrc.startsWith('http')) {
        const imgPath = path.join('static', imgSrc.replace(/^\//, ''));
        if (!fs.existsSync(imgPath)) {
          this.addIssue('error', filePath, lineNumber, 
            `Imagem n√£o encontrada: ${imgSrc}`);
        }
      }
    }
  }

  addIssue(type, file, line, message, fixable = false) {
    const issue = {
      type,
      file,
      line,
      message,
      fixable,
      timestamp: new Date().toISOString()
    };
    
    if (type === 'error') {
      this.issues.push(issue);
      this.stats.issuesFound++;
    } else {
      this.warnings.push(issue);
      this.stats.warningsFound++;
    }
    
    if (fixable) {
      this.stats.fixableIssues++;
    }
  }

  async generateReport() {
    console.log('\n' + '='.repeat(60));
    console.log('üìê RELAT√ìRIO DE VERIFICA√á√ÉO DE FORMATA√á√ÉO');
    console.log('='.repeat(60));
    
    console.log(`üìÑ Arquivos verificados: ${this.stats.filesChecked}`);
    console.log(`‚ùå Problemas encontrados: ${this.stats.issuesFound}`);
    console.log(`‚ö†Ô∏è  Avisos: ${this.stats.warningsFound}`);
    console.log(`üîß Problemas corrig√≠veis: ${this.stats.fixableIssues}`);
    
    // Calcular score de qualidade
    const totalIssues = this.stats.issuesFound + this.stats.warningsFound;
    const qualityScore = this.stats.filesChecked > 0 
      ? Math.max(0, 100 - (totalIssues / this.stats.filesChecked * 10))
      : 100;
    
    console.log(`üìä Score de qualidade: ${Math.round(qualityScore)}/100`);
    
    // Mostrar problemas por categoria
    this.showIssuesByCategory();
    
    // Mostrar problemas cr√≠ticos
    if (this.issues.length > 0) {
      console.log('\n‚ùå PROBLEMAS CR√çTICOS:');
      this.issues.slice(0, 10).forEach(issue => {
        console.log(`   üìÑ ${issue.file}:${issue.line} - ${issue.message}`);
      });
      
      if (this.issues.length > 10) {
        console.log(`   ... e mais ${this.issues.length - 10} problema(s)`);
      }
    }
    
    // Mostrar principais avisos
    if (this.warnings.length > 0) {
      console.log('\n‚ö†Ô∏è  PRINCIPAIS AVISOS:');
      this.warnings.slice(0, 5).forEach(warning => {
        console.log(`   üìÑ ${warning.file}:${warning.line} - ${warning.message}`);
        if (warning.fixable) {
          console.log(`      üîß Corrig√≠vel automaticamente`);
        }
      });
      
      if (this.warnings.length > 5) {
        console.log(`   ... e mais ${this.warnings.length - 5} aviso(s)`);
      }
    }
    
    // Gerar recomenda√ß√µes
    this.generateRecommendations();
    
    // Salvar relat√≥rio detalhado
    const report = {
      timestamp: new Date().toISOString(),
      stats: this.stats,
      qualityScore: Math.round(qualityScore),
      issues: this.issues,
      warnings: this.warnings,
      rules: this.rules
    };
    
    fs.writeFileSync('format-check-report.json', JSON.stringify(report, null, 2));
    console.log('\nüìÑ Relat√≥rio detalhado salvo em: format-check-report.json');
    
    if (this.stats.issuesFound > 0) {
      console.log('\n‚ö†Ô∏è  Problemas cr√≠ticos encontrados. Recomenda-se corre√ß√£o.');
      process.exit(1);
    } else {
      console.log('\nüéâ Formata√ß√£o est√° em conformidade!');
    }
  }

  showIssuesByCategory() {
    const allIssues = [...this.issues, ...this.warnings];
    const categories = {};
    
    allIssues.forEach(issue => {
      const category = this.categorizeIssue(issue.message);
      if (!categories[category]) categories[category] = 0;
      categories[category]++;
    });
    
    if (Object.keys(categories).length > 0) {
      console.log('\nüìä Problemas por categoria:');
      Object.entries(categories)
        .sort(([,a], [,b]) => b - a)
        .forEach(([category, count]) => {
          console.log(`   ${category}: ${count} ocorr√™ncia(s)`);
        });
    }
  }

  categorizeIssue(message) {
    if (message.includes('Heading') || message.includes('H1')) return 'üìù Headings';
    if (message.includes('Link') || message.includes('link')) return 'üîó Links';
    if (message.includes('Imagem') || message.includes('alt')) return 'üñºÔ∏è  Imagens';
    if (message.includes('linha') || message.includes('espa√ßo')) return 'üìê Espa√ßamento';
    if (message.includes('lista')) return 'üìã Listas';
    if (message.includes('c√≥digo')) return 'üíª C√≥digo';
    if (message.includes('pontua√ß√£o')) return 'üìù Pontua√ß√£o';
    return 'üìÑ Geral';
  }

  generateRecommendations() {
    console.log('\nüí° RECOMENDA√á√ïES:');
    
    const recommendations = [];
    
    if (this.stats.fixableIssues > 0) {
      recommendations.push(`‚Ä¢ ${this.stats.fixableIssues} problema(s) podem ser corrigidos automaticamente`);
    }
    
    const headingIssues = [...this.issues, ...this.warnings]
      .filter(i => i.message.includes('Heading') || i.message.includes('H1')).length;
    if (headingIssues > 0) {
      recommendations.push('‚Ä¢ Revisar estrutura de headings para melhor hierarquia');
    }
    
    const linkIssues = [...this.issues, ...this.warnings]
      .filter(i => i.message.includes('Link') || i.message.includes('link')).length;
    if (linkIssues > 0) {
      recommendations.push('‚Ä¢ Verificar e corrigir links quebrados ou mal formatados');
    }
    
    const imageIssues = [...this.issues, ...this.warnings]
      .filter(i => i.message.includes('Imagem') || i.message.includes('alt')).length;
    if (imageIssues > 0) {
      recommendations.push('‚Ä¢ Adicionar alt text descritivo em todas as imagens');
    }
    
    if (this.stats.warningsFound > this.stats.issuesFound * 2) {
      recommendations.push('‚Ä¢ Considerar automatizar corre√ß√£o de formata√ß√£o com ferramentas como Prettier');
    }
    
    if (recommendations.length === 0) {
      recommendations.push('‚Ä¢ Formata√ß√£o est√° excelente! Continue mantendo os padr√µes.');
    }
    
    recommendations.forEach(rec => console.log(rec));
  }
}

// Executar se chamado diretamente
if (require.main === module) {
  const checker = new FormatChecker();
  checker.check().catch(console.error);
}

module.exports = FormatChecker;